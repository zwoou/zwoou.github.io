---
title: 多线程
date: 2017-08-28 13:53:37 
tags: 多线程
---

## 基本概念 ##
1. 进程：是一个执行中的程序，每一个进程执行都有一个执行顺序，该顺序是一个执行路径，或者叫一个控制单元。
进程：一个计算机程序的运行实例，包含了需要执行的指令；有自己的独立地址空间，包含程序内容和数据；
不同进程的地址空间是互相隔离的；进程拥有各种资源和状态信息，包括打开的文件、子进程和信号处理。
线程：表示程序的执行流程，是CPU调度执行的基本单位；线程有自己的程序计数器、寄存器、堆栈和帧。
同一进程中的线程共用相同的地址空间，同时共享进进程锁拥有的内存和其他资源。
volatile 的定义
java编程允许线程访问共享变量，为了确保共享变量能被准确和一致性的更新，线程应该确保通过排他锁单独获得这个变量。
<!-- more -->
synchronized 的实现原理与应用
java中每一个对象都可以作为锁。具体表现：
    1. 对于普通同步方法，锁是当前实例对象。
    2. 对于静态同步方法，锁是当前类的Class对象。
    3. 对于同步方法块，锁是Synchonized括号里配置的对象。
锁的升级
级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态。
2. Java标准库提供了进程和线程相关的API，进程主要包括表示进程的java.lang.Process类和创建进程的java.lang.ProcessBuilder类；
3. 线程间的可见性：一个线程对进程中共享的数据的修改，是否对另一个线程可见
可见性问题：
    a. CPU采用时间片轮转等不同算法来对线程进行调度
    b. cpu缓存
    c. 指令顺序重排。
4. 死锁
死锁： 线程间互相等待对方释放锁。
**避免死锁常用方法**
- 避免一个线程同时获取多个锁
- 避免一个线程在锁内同时占用多个资源，尽量保证一个线程占用一个资源。
- 尝试使用定时锁，使用lock.tryLock(timeout)来替代内部锁机制。
- 对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败情况。

**Java内存模型（Java Memory Model）**
屏蔽了CPU缓存等细节，只关注主存中的共享变量；关注对象的实例域、静态域和数组元素；关注线程间的动作。
1. volatile关键字用来对共享变量的访问进行同步，上一次写入操作的结果对下一次读取操作是肯定可见的。（在写入volatile变量值之后，CPU缓存中的内容会被写回内存；在读取volatile变量时，CPU缓存中的对应内容会被置为失效，重新从主存中进行读取），volatile不使用锁，性能优于synchronized关键词。
2. final关键词
final关键词声明的域的值只能被初始化一次，一般在构造方法中初始化。。（在多线程开发中，final域通常用来实现不可变对象）
当对象中的共享变量的值不可能发生变化时，在多线程中也就不需要同步机制来进行处理，故在多线程开发中应尽可能使用不可变对象。
另外，在代码执行时，final域的值可以被保存在寄存器中，而不用从主存中频繁重新读取。















