# JVM垃圾回收

[TOC]



判读一个对象是否可回收



## 1. 引用计数算法(Reference Counting)



给对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。
两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致 GC 收集器无法回收。



## 2. 可达性分析算法



这个算法的基本思路就是通过一系列的称为“GC Roots”的对象作为起点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain),当一个对象到GC Roots 没有任何引用链相连时，则证明此对象是不可用的。
在java语言中，可作为GC Roots的对象包括：

       1. 虚拟机栈（栈帧中的本地变量表）中引用的对象。
    2. 方法区中类静态属性引用的对象。
    3. 方法区中常量引用的对象。譬如字符串常量池(Strong Table) 里的引用
    4. 本地方法栈中JNI(即一般说的native方法)引用的对象。
    5. Java虚拟机内部的引用,如基本数据类型对应的Class对象,一些常驻的异常对象
    6. 所有被同步锁(synchronized关键字)持有的对象
    7. 反映Java虚拟机内部情况的JMXBean,JVMTI中注册的回调,本地代码缓存等



## 3. 引用类型



1. 强引用
   只要强引用存在，垃圾回收器永远不会回收调掉被引用的对象。使用 new 一个新对象的方式来创建强引用。

2. 软引用
   用来描述一些还有用但是并非必需的对象。使用 SoftReference 类来实现软引用。

3. 弱引用
   只能生存到下一次垃圾收集发生之前，当垃圾收集器工作时，无论当前内存是否足够，都会被回收。使用 WeakReference 类来实现弱引用。

4. 虚引用       又称为幽灵引用或者幻影引用.一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。使用 PhantomReference 来实现虚引用。

   

## 4. 方法区的回收



因为方法区主要存放永久代对象，而永久代对象的回收率比新生代差很多，因此在方法区上进行回收性价比不高。
在方法区主要是对常量池的回收和对类的卸载。

常量池的回收和堆中对象回收类似。
类的卸载条件很多，需要满足以下三个条件，并且满足了也不一定会被卸载：
       1. 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。
    2. 加载该类的 ClassLoader 已经被回收。
    3. 该类对应的 java.lang.Class 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。
  可以通过 -Xnoclassgc 参数来控制是否对类进行卸载.



## 5. finalize()



finalize() 类似 C++ 的析构函数，用来做关闭外部资源等工作。但是 try-finally 等方式可以做的更好，并且该方法运行代价高昂，不确定性大，无法保证各个对象的调用顺序，因此最好不要使用。
当一个对象可被回收时，如果需要执行该对象的 finalize() 方法，那么就有可能通过在该方法中让对象重新被引用，从而实现自救。





##   6. 垃圾回收算法



内存分代 图jvm-5

[![PYemiq.png](https://s1.ax1x.com/2018/07/24/PYemiq.png)](https://imgchr.com/i/PYemiq)   
一开始对象的创建都发生在新生代，随着对象的不断创建，如果新生代没有空间创建对象，将会发生GC,这时的GC称为Minor GC,位于新生代的对象每经历一次Minor GC后，如果这个对象没有被回收，则标记数会加1，这个标记数将标记这个对象经历了多少次的Minor GC，对于Sun的Hotspot虚拟机，如果这个次数超过15（默认15）该对象才会被移动到老年代。
随着时间的推移，如果老年代也没有足够的空间容纳对象，老年代也会试着发起GC，称为 Full GC.相比Minor GC，Full GC发生的次数比较少，但是每发生一次Full GC ,整个堆内存区域都需要执行一次垃圾回收，效率低。
Stop the World事件-所有 minor garbage collections都是Stop the World事件。也就是所有应用线程都需要停止，直到垃圾回收的操作完成。



- 标记-清除算法（Mark-Sweep）
      缺点：1. 效率低。2. 空间问题，标记清除后会产生不连续的内存碎片。
  - 标记-复制算法（Copying）
      IBM研究，新生代分为三部分，一块较大的Eden(伊甸园)和两块较小的Survivor（幸存者）区域。HotSpot默认比例8：1。
  - 标记-整理算法(Mark-Compact)
         标记过程和“标记-清除”一样，然后让所有存活的对象都向一端移动，然后清理掉端边界以外的内存。这种方法避免了碎片的产生，同时也不需要一块额外的内存空间，对于老年代比较合适。
       这两种算法精炼语言描述：
  - 复制算法：用空间换时间
  - 标记-整理算法： 用时间换空间
        


## 7. 垃圾收集

- 垃圾收集器
    1. Serial收集器
        单线程收集器，运行在客户端模式是最好的选择，优点是：简单高效 ，会造成Stop the World事件
    2. ParNew收集器
        Serial收集器的多线程版本，是 Server 模式下的虚拟机首选新生代收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合工作。
    3. Parallel Scavenge收集器
        是并行的多线程收集器。       其它收集器关注点是尽可能缩短垃圾收集时用户线程的停顿时间，而它的目标是达到一个可控制的吞吐量，它被称为“吞吐量优先”收集器。这里的吞吐量指 CPU 用于运行用户代码的时间占总时间的比值。
    4. Serial Old收集器
    
    5. Parallel Old收集器
    6. CMS收集器
        CMS（Concurrent Mark Sweep），从 Mark Sweep 可以知道它是基于标记-清除算法实现的。
        特点：并发收集、低停顿。
    7. G1收集器        
        G1（Garbage-First）收集器是当今收集器技术发展最前沿的成果之一，它是一款面向服务端应用的垃圾收集器，HotSpot 开发团队赋予它的使命是（在比较长期的）未来可以替换掉 JDK 1.5 中发布的 CMS 收集器。
    8. 七种垃圾收集器的比较
- 内存分配与回收策略
    1. 优先在Eden分配
    2. 大对象直接进入老年代
        -XX:PretenureSizeThreshold 参数
    3. 长期存活的对象进入老年代
        JVM 为对象定义年龄计数器，经过 Minor GC 依然存活，并且能被 Survivor 区容纳的，移被移到 Survivor 区，年龄就增加 1 岁，增加到一定年龄则移动到老年代中（默认 15 岁，通过 -XX:MaxTenuringThreshold 设置）。
    4. 动态对象年龄判定
        JVM 并不是永远地要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 区中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无序等待 MaxTenuringThreshold 中要求的年龄。
    5.  空间分配担保
        在发生 Minor GC 之前，JVM 先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的；如果不成立的话 JVM 会查看 HandlePromotionFailure 设置值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC，尽管这次 Minor GC 是有风险的；如果小于，或者 HandlePromotionFailure 设置不允许冒险，那这时也要改为进行一次 Full GC。
- Full GC的触发条件
    1. 调用System.gc()
        此方法的调用是建议 JVM 进行 Full GC，虽然只是建议而非一定，但很多情况下它会触发 Full GC，从而增加 Full GC 的频率，也即增加了间歇性停顿的次数。因此强烈建议能不使用此方法就不要使用，让虚拟机自己去管理它的内存。可通过 -XX:+ DisableExplicitGC 来禁止 RMI 调用 System.gc()。
    2. 老年代空间不足
    3. 空间分配担保失败
    4. JDK 1.7 及以前的永久代空间不足
    5. Concurrent Mode Failure
    
        执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足（有时候“空间不足”是 CMS GC 时当前的浮动垃圾过多导致暂时性的空间不足触发 Full GC），便会报 Concurrent Mode Failure 错误，并触发 Full GC。
## 8. G1收集器 
G1把整个Java堆划分为若干个区间（Regions),每个Region大小为2的倍数，范围在1MB-32MB之间。
G1年轻代收集器是并行Stop-the-world收集器，和其他的HotSpot GC一样，当一个年轻代GC发生时，整个年轻代被回收。   