---
title: 红黑树
tags:
    - 数据结构
    - 红黑树
---
## R-B Tree 简介
全称是Red-Black Tree ,是一种特殊的二叉查找树。
特性：
1. 每个节点或者是黑色或者是红色
2. 根节点是黑色
3. 每个叶子节点（NIL)是黑色。[注意：这里叶子节点 ，是指为空（NIL或NULL)的节点]
4. 如果一个节点是红色的，则他的子节点必须是黑色的。
5. 从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。
## 红黑树的应用
红黑树的应用比较广泛，主要是用它来存储有序的数据，它的时间复杂度是O(lgn)，效率非常之高。
例如，Java集合中的TreeSet和TreeMap。
## 红黑树的时间复杂度和相关证明
红黑树的时间复杂度为: O(lgn)
下面通过“数学归纳法”对红黑树的时间复杂度进行证明
## 红黑树的基本操作(一) 左旋和右旋
红黑树的基本操作是添加、删除。在对红黑树进行添加或删除之后，都会用到旋转方法。为什么呢？道理很简单，添加或删除红黑树中的节点之后，红黑树就发生了变化，可能不满足红黑树的5条性质，也就不再是一颗红黑树了，而是一颗普通的树。而通过旋转，可以使这颗树重新成为红黑树。简单点说，旋转的目的是让树保持红黑树的特性。
旋转包括两种：左旋 和 右旋。下面分别对它们进行介绍。
1. 左旋	
2. 右旋
## 红黑树的基本操作(二) 添加
将一个节点插入到红黑树中，需要执行哪些步骤呢？首先，将红黑树当作一颗二叉查找树，将节点插入；然后，将节点着色为红色；最后，通过旋转和重新着色等方法来修正该树，使之重新成为一颗红黑树。详细描述如下：
1. 第一步: 将红黑树当作一颗二叉查找树，将节点插入。
       红黑树本身就是一颗二叉查找树，将节点插入后，该树仍然是一颗二叉查找树。也就意味着，树的键值仍然是有序的。此外，无论是左旋还是右旋，若旋转之前这棵树是二叉查找树，旋转之后它一定还是二叉查找树。这也就意味着，任何的旋转和重新着色操作，都不会改变它仍然是一颗二叉查找树的事实。
       好吧？那接下来，我们就来想方设法的旋转以及重新着色，使这颗树重新成为红黑树！
2. 将插入的节点着色为"红色"。
 将插入的节点着色为红色，不会违背"特性(5)"！少违背一条特性，就意味着我们需要处理的情况越少。
3.  通过一系列的旋转或着色等操作，使之重新成为一颗红黑树。
       第二步中，将插入节点着色为"红色"之后，不会违背"特性(5)"。那它到底会违背哪些特性呢？
       对于"特性(1)"，显然不会违背了。因为我们已经将它涂成红色了。
       对于"特性(2)"，显然也不会违背。在第一步中，我们是将红黑树当作二叉查找树，然后执行的插入操作。而根据二叉查找数的特点，插入操作不会改变根节点。所以，根节点仍然是黑色。
       对于"特性(3)"，显然不会违背了。这里的叶子节点是指的空叶子节点，插入非空节点并不会对它们造成影响。
       对于"特性(4)"，是有可能违背的！
       那接下来，想办法使之"满足特性(4)"，就可以将树重新构造成红黑树了。
    
    
    
    
    
## 参考
- [http://www.cnblogs.com/skywang12345/p/3245399.html](http://www.cnblogs.com/skywang12345/p/3245399.html)   
    
    
    
1. Getting Started; Heap

    Sorting的方法&分析
    Growth of Function
    Insertion Sort上机
    Sorting   Lower Bound

2. Basic   Data Structures I (List, Queue, Stack) 

    Pointers in C

    Basic Data StructureⅠ- 1

    Basic Data StructureⅠ- 2
    
3.   Basic Data Structures II   (Tree, Graph)

    Tree and Graph

4. Graph and Tree Traversals I   (BFS, DFS)

    Breadth First Search

    Depth First Search

    Depth First Search分析
5. 