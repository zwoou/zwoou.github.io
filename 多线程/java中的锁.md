# 锁

分类:

- 乐观锁/悲观锁
- 公平锁/非公平锁
- 共享锁/独占锁
- 偏向锁/轻量级锁/重量级锁
- 自旋锁

## 1. synchronized

如图，synchronized可以用在**方法**上也可以使用在**代码块**中，其中方法是实例方法和静态方法分别锁的是该类的实例对象和该类的对象。而使用在代码块中也可以分为三种，具体的可以看上面的表格。这里的需要注意的是：**如果锁的是类对象的话，尽管new多个实例对象，但他们仍然是属于同一个类依然会被锁住，即线程之间保证同步关系**。

- 对象锁（monitor）机制

  **每个对象拥有一个计数器，当线程获取该对象锁后，计数器就会加一，释放锁后就会将计数器减一**。

1. 作用范围
   java中每一个对象都可以作为锁。具体表现：
    1. 对于普通同步方法，锁是当前实例对象。
    2. 对于静态同步方法，锁是当前类的Class对象。
    3. 对于同步方法块，锁是Synchonized括号里配置的对象。
2. 锁的升级
级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态。

## 2. ReentrantLock

## 锁优化

1. 自旋锁与自适应自旋
自旋锁在JDK1.4.2中就已经引入，只不过默认关闭的
JDK1.6默认开启
-XX：PreBlockSpin 自旋次数默认10次
2. 锁消除
锁消除是指虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。
3. 锁粗化
4. 轻量级锁
本意是在没有多线程竞争的前提下，减少传统重量级锁使用操作系统互斥量产生的性能消耗。
虚拟机对象头包含两部分
第一部分用于存储对象自身的运行时数据。如哈西吗（HashCode）、GC分代年龄等
这部分数据长度为32位或64位，官方称为“MarkWord"
第二部分用于存储指向方法区对象类型数据的指针，如果是数组，还有一个额外部分用于存储数组长度。
轻量级锁能提升程序同步性能的依据是”对于绝大部分的锁，在整个同步周期内都是不存在竞争的“，
这是一个经验数据，如果存在锁的竞争，除了互斥量的开销外，还发生了CAS操作，
因此在有竞争的情况下，轻量级锁会比传统锁慢。
5. 偏向锁
也是JDK1.6中引入的一项锁优化。去除了CAS操作。
偏向锁的”偏“，意思是锁会偏向于第一个获取他的线程。
-XX:+UseBiasedLocking 默认打开






​    





 







































































































































