# 多线程

[TOC]

## 1. 基本概念 ##

1. 进程：是一个执行中的程序，每一个进程执行都有一个执行顺序，该顺序是一个执行路径，或者叫一个控制单元。
进程：一个计算机程序的运行实例，包含了需要执行的指令；有自己的独立地址空间，包含程序内容和数据；
不同进程的地址空间是互相隔离的；进程拥有各种资源和状态信息，包括打开的文件、子进程和信号处理。
线程：表示程序的执行流程，是CPU调度执行的基本单位；线程有自己的程序计数器、寄存器、堆栈和帧,并且能够访问共享的内存变量。
同一进程中的线程共用相同的地址空间，同时共享进进程锁拥有的内存和其他资源。

## 2. 线程优先级



## 3. 线程的状态



| 状态名称     | 说明         |
| ------------ | ------------ |
| NEW          | 初始状态     |
| RUNNABLE     | 运行状态     |
| BLOCKED      | 阻塞状态     |
| WAITING      | 等待状态     |
| TIME_WAITING | 超时等待状态 |
| TERMINATED   | 终止状态     |



## 4. Daemon线程



## 5. 启动和终止线程



## 6. 线程间通信



### 6.1 volatile和synchronized关键字



### 6.2 等待/通知机制



### 6.3 管道输入/输出流



### 6.4 Thread.join()的使用



### 6.5 ThreadLocal的使用



## 7. 线程应用实例



### 7.1 等待超时模式



### 7.2 数据库连接池







volatile 的定义
java编程允许线程访问共享变量，为了确保共享变量能被准确和一致性的更新，线程应该确保通过排他锁单独获得这个变量。
synchronized 的实现原理与应用
java中每一个对象都可以作为锁。具体表现：

    1. 对于普通同步方法，锁是当前实例对象。
        2. 对于静态同步方法，锁是当前类的Class对象。
        3. 对于同步方法块，锁是Synchonized括号里配置的对象。
锁的升级
级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态。

2. Java标准库提供了进程和线程相关的API，进程主要包括表示进程的java.lang.Process类和创建进程的java.lang.ProcessBuilder类；
3. 线程间的可见性：一个线程对进程中共享的数据的修改，是否对另一个线程可见
可见性问题：
    a. CPU采用时间片轮转等不同算法来对线程进行调度
    b. cpu缓存
    c. 指令顺序重排。
4. 死锁
死锁： 线程间互相等待对方释放锁。
**避免死锁常用方法**
- 避免一个线程同时获取多个锁
- 避免一个线程在锁内同时占用多个资源，尽量保证一个线程占用一个资源。
- 尝试使用定时锁，使用lock.tryLock(timeout)来替代内部锁机制。
- 对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败情况。

**Java内存模型（Java Memory Model）**
屏蔽了CPU缓存等细节，只关注主存中的共享变量；关注对象的实例域、静态域和数组元素；关注线程间的动作。

1. volatile关键字用来对共享变量的访问进行同步，上一次写入操作的结果对下一次读取操作是肯定可见的。（在写入volatile变量值之后，CPU缓存中的内容会被写回内存；在读取volatile变量时，CPU缓存中的对应内容会被置为失效，重新从主存中进行读取），volatile不使用锁，性能优于synchronized关键词。
2. final关键词
final关键词声明的域的值只能被初始化一次，一般在构造方法中初始化。。（在多线程开发中，final域通常用来实现不可变对象）
当对象中的共享变量的值不可能发生变化时，在多线程中也就不需要同步机制来进行处理，故在多线程开发中应尽可能使用不可变对象。
另外，在代码执行时，final域的值可以被保存在寄存器中，而不用从主存中频繁重新读取。















