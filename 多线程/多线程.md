# 多线程

[TOC]

## 1. 基本概念 ##

1. 进程：是一个执行中的程序，每一个进程执行都有一个执行顺序，该顺序是一个执行路径，或者叫一个控制单元。
进程：一个计算机程序的运行实例，包含了需要执行的指令；有自己的独立地址空间，包含程序内容和数据；
不同进程的地址空间是互相隔离的；进程拥有各种资源和状态信息，包括打开的文件、子进程和信号处理。
2. 线程：表示程序的执行流程，是CPU调度执行的基本单位；线程有自己的程序计数器、寄存器、堆栈和帧,并且能够访问共享的内存变量。
    同一进程中的线程共用相同的地址空间，同时共享进进程锁拥有的内存和其他资源。
3. 新建线程
  - 通过继承Thread类
  - 通过实现runable接口
  - 通过实现callable接口

## 2. 线程优先级

## 3. 线程的状态

| 状态名称     | 说明         |
| ------------ | ------------ |
| NEW          | 初始状态     |
| RUNNABLE     | 运行状态     |
| BLOCKED      | 阻塞状态     |
| WAITING      | 等待状态     |
| TIME_WAITING | 超时等待状态 |
| TERMINATED   | 终止状态     |



## 4. Daemon线程



## 5. 启动和终止线程



## 6. 线程间通信



### 6.1 volatile和synchronized关键字



### 6.2 等待/通知机制



### 6.3 管道输入/输出流



### 6.4 Thread.join()的使用



如图，synchronized可以用在**方法**上也可以使用在**代码块**中，其中方法是实例方法和静态方法分别锁的是该类的实例对象和该类的对象。而使用在代码块中也可以分为三种，具体的可以看上面的表格。这里的需要注意的是：**如果锁的是类对象的话，尽管new多个实例对象，但他们仍然是属于同一个类依然会被锁住，即线程之间保证同步关系**。

- 对象锁（monitor）机制

  **每个对象拥有一个计数器，当线程获取该对象锁后，计数器就会加一，释放锁后就会将计数器减一**。

  

### 6.5 ThreadLocal的使用



## 7. 线程应用实例



### 7.1 等待超时模式



### 7.2 数据库连接池







volatile 的定义
java编程允许线程访问共享变量，为了确保共享变量能被准确和一致性的更新，线程应该确保通过排他锁单独获得这个变量。
synchronized 的实现原理与应用
java中每一个对象都可以作为锁。具体表现：

    1. 对于普通同步方法，锁是当前实例对象。
        2. 对于静态同步方法，锁是当前类的Class对象。
        3. 对于同步方法块，锁是Synchonized括号里配置的对象。
锁的升级
级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态。

2. Java标准库提供了进程和线程相关的API，进程主要包括表示进程的java.lang.Process类和创建进程的java.lang.ProcessBuilder类；
3. 线程间的可见性：一个线程对进程中共享的数据的修改，是否对另一个线程可见
可见性问题：
    a. CPU采用时间片轮转等不同算法来对线程进行调度
    b. cpu缓存
    c. 指令顺序重排。
4. 死锁
死锁： 线程间互相等待对方释放锁。
**避免死锁常用方法**
- 避免一个线程同时获取多个锁
- 避免一个线程在锁内同时占用多个资源，尽量保证一个线程占用一个资源。
- 尝试使用定时锁，使用lock.tryLock(timeout)来替代内部锁机制。
- 对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败情况。

**Java内存模型（Java Memory Model）**
屏蔽了CPU缓存等细节，只关注主存中的共享变量；关注对象的实例域、静态域和数组元素；关注线程间的动作。

1. volatile关键字用来对共享变量的访问进行同步，上一次写入操作的结果对下一次读取操作是肯定可见的。（在写入volatile变量值之后，CPU缓存中的内容会被写回内存；在读取volatile变量时，CPU缓存中的对应内容会被置为失效，重新从主存中进行读取），volatile不使用锁，性能优于synchronized关键词。
2. final关键词
final关键词声明的域的值只能被初始化一次，一般在构造方法中初始化。。（在多线程开发中，final域通常用来实现不可变对象）
当对象中的共享变量的值不可能发生变化时，在多线程中也就不需要同步机制来进行处理，故在多线程开发中应尽可能使用不可变对象。
另外，在代码执行时，final域的值可以被保存在寄存器中，而不用从主存中频繁重新读取。

## 8. 并发编程有哪些缺点

### 1. 频繁的上下文切换

通常减少上下文切换可以采用无锁并发编程,CAS算法,使用最少线程和使用协程

- 无锁并发编程：可以参照concurrentHashMap锁分段的思想，不同的线程处理不同段的数据，这样在多线程竞争的条件下，可以减少上下文切换的时间。

- CAS算法，利用Atomic下使用CAS算法来更新数据，使用了乐观锁，可以有效的减少一部分不必要的锁竞争带来的上下文切换

- 使用最少线程：避免创建不需要的线程，比如任务很少，但是创建了很多的线程，这样会造成大量的线程都处于等待状态

- 协程：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换

### 2. 线程安全



## synchronized优化



## CAS操作

CAS比较交换的过程可以通俗的理解为CAS(V,O,N)，包含三个值分别为：**V 内存地址存放的实际值；O 预期的值（旧值）；N 更新的新值**。

### CAS的问题

1. ABA问题

   因为CAS会检查旧值有没有变化，这里存在这样一个有意思的问题。比如一个旧值A变为了成B，然后再变成A，刚好在做CAS时检查发现旧值并没有变化依然为A，但是实际上的确发生了变化。解决方案可以沿袭数据库中常用的乐观锁方式，添加一个版本号可以解决。原来的变化路径A->B->A就变成了1A->2B->3C。java这么优秀的语言，当然在java 1.5后的atomic包中提供了AtomicStampedReference来解决ABA问题，解决思路就是这样的

2. 自旋时间过长
   使用CAS时非阻塞同步，也就是说不会将线程挂起，会自旋（无非就是一个死循环）进行下一次尝试，如果这里自旋时间过长对性能是很大的消耗。如果JVM能支持处理器提供的pause指令，那么在效率上会有一定的提升。

3.  **只能保证一个共享变量的原子操作**

当对一个共享变量执行操作时CAS能保证其原子性，如果对多个共享变量进行操作,CAS就不能保证其原子性。有一个解决方案是利用对象整合多个共享变量，即一个类中的成员变量就是这几个共享变量。然后将这个对象做CAS操作就可以保证其原子性。atomic中提供了AtomicReference来保证引用对象之间的原子性


## Java对象头

Java SE 1.6中，锁一共有4种状态，级别从低到高依次是：**无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态**，这几个状态会随着竞争情况逐渐升级。**锁可以升级但不能降级**，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率。对象的MarkWord变化为下图