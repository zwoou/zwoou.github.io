---
title: 深入理解java虚拟机--线程安全与锁优化
tags:
    - JVM
    - 多线程
---
## 线程安全
1. 不可变
基本类型，定义时使用final关键字。
引用类型。对象的行为对其状态不会产生任何影响。
保证对象行为不影响自己状态的途径有多种，简单办法是把对象中带有状态的变量都声明为final.
2. 绝对线程安全
满足Brian Goetz给出的线程安全定义
不管运行时环境如何，调用者都不需要额外的同步措施。
如
3. 相对线程安全
4. 线程兼容
线程兼容是指对象本身并不是线程安全的，但是可用在调用端正确使用同步手段来保证在并发环境中安全的使用。
5. 线程对立
线程对立是指无论在调用端是否采用同步手段，都无法在多线程中并发使用代码。
如System.setIn(),System.setOut().
## 线程安全实现方法
1. 互斥同步
同步是指在多个线程并发访问共享数据时，保证共享数据在同一时刻只被一个线程使用。
互斥是实现同步的手段。临界区、互斥量、信号量都是主要实现方式。
在java中，最基本的互斥同步手段是Synchronized.
synchronized关键字编译后，会在同步快前后分别形成monitorenter和monitorexit这两个字节码指令。
这个字节码需要一个 reference类型的参数来指定要锁定解锁的对象。
如果synchronized明确了对象参数，那就是这个对象的reference.
如果不指定，根据修饰的是实例方法还是类方法，去取对象实例或Class对象来作为锁对象。

首先，synchronized同步块对同一个线程来说是可重入的，不会出现自己把自己锁死。
其次，同步块在已进入的线程执行完之前，会阻塞后面其他线程的进入。
java的线程是映射到操作系统的原生线程之上的，如果要阻塞或唤醒一个线程都需要操作系统来帮忙完成，这就需要用户态转到核心态，因此状态转换需要消耗很多处理器时间。
因此，虚拟机本身进行了优化，比如在通知操作系统阻塞线程之前加入一段自旋等待过程，避免频繁的切入到核心态之中。

除了synchronized之外，可以使用java.util.concurrent包中的重入锁（ReentrantLock）来实现同步。
ReentantLock增加高级特性，主要三个，等待可中断，可实现公平锁，以及锁可以绑定多个条件。
    - 等待可中断是指当持有锁的线程长期不释放锁时，正在等待的线程可以放弃等待。
    - 公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获取锁。
    ReentantLock默认也是非公平的，但可以通过带布尔值的构造函数要求使用公平锁。
    - 锁绑定多个条件是指一个ReentrantLock对象可以同时绑定多个Condition方法。只需要调用newCondition()方法即可。
2. 非阻塞同步
使用乐观并发策略需要“硬件指令集”的发展
这类指令集有：
    - 测试并设置（Test-and-Set)
    - 获取并增加（Fetch-and-Increment)
    - 交换（Swap)
    - 比较并交换（Compare-and-Swap ),下文称CAS
    - 加载连接/条件存储（Load-Linked/Store-Condditinal ,下文称LL/SC)
CAS缺陷：“ABA问题”
JUC解决了这个问题，带有标记的原子引用类“AtomicStampedReference”
不过比较鸡肋，大部分ABA问题不会影响程序并发正确性。使用互斥同步可能比原子类更高效。

3. 无同步方案
要保证线程安全，并不是一定就要进行同步，两者没有必然关系。
    - 可重入代码（Reentant Code）这种代码也叫做纯代码。
    - 线程本地存储（Thread Local Storage）
    如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享的数据代码能否能保证在同一个代码中执行？
    如果能保证，就可以把共享数据的可见范围控制在同一个线程中。
    这样无需同步也可以保证线程之间不出现数据争用的问题。
符合这种特点的应用不少见。
大部分使用消息队列的架构（生产者-消费者模式）都会将产品的消费过程尽量在一个线程中消费完。
经典Web交互模型“一个请求对应一个线程”
java.lang.ThreadLocal类实现线程本地存储
## 锁优化
1. 自旋锁与自适应自旋
自旋锁在JDK1.4.2中就已经引入，只不过默认关闭的
JDK1.6默认开启
-XX：PreBlockSpin 自旋次数默认10次
2. 锁消除
锁消除是指虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。
3. 锁粗化
4. 轻量级锁
本意是在没有多线程竞争的前提下，减少传统重量级锁使用操作系统互斥量产生的性能消耗。
虚拟机对象头包含两部分
第一部分用于存储对象自身的运行时数据。如哈西吗（HashCode）、GC分代年龄等
这部分数据长度为32位或64位，官方称为“MarkWord"
第二部分用于存储指向方法区对象类型数据的指针，如果是数组，还有一个额外部分用于存储数组长度。
轻量级锁能提升程序同步性能的依据是”对于绝大部分的锁，在整个同步周期内都是不存在竞争的“，
这是一个经验数据，如果存在锁的竞争，除了互斥量的开销外，还发生了CAS操作，
因此在有竞争的情况下，轻量级锁会比传统锁慢。
5. 偏向锁
也是JDK1.6中引入的一项锁优化。去除了CAS操作。
偏向锁的”偏“，意思是锁会偏向于第一个获取他的线程。
-XX:+UseBiasedLocking 默认打开





    
    





 







































































































































