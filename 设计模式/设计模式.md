---
title: 设计模式  
tags:
    - 设计模式
---
## 概述  
## 原则   
1. 找出应用中可能需要变化指出，把他独立出来，不要和其他不需要变化的代码放在一起。
2. 针对接口编程，而不是针对实现编程。 
3. 多用组合，少用继承
4. 松耦合设计
5. 类应该对扩展开放，对修改关闭。
## 设计模式  
<!-- more -->
## 创建型
### 1. 单例（Singleton)  
#### 意图  
确保一个类只有一个实例，并提供该实例的全局访问点。
#### 类图
使用一个*私有构造函数*，一个*私有静态变量*，和一个*公有静态方法*实现。
#### 实现
1. 懒汉式-线程不安全
```
public class Singleton {

    private static Singleton uniqueInstance;

    private Singleton() {
    }

    public static Singleton getUniqueInstance() {
        if (uniqueInstance == null) {
            uniqueInstance = new Singleton();
        }
        return uniqueInstance;
    }
}
```
2. 懒汉式- 线程安全
只需要对 getUniqueInstance() 方法加锁，那么在一个时间点只能有一个线程能够进入该方法，从而避免了对 uniqueInstance 进行多次实例化的问题。

但是这样有一个问题，就是当一个线程进入该方法之后，其它线程试图进入该方法都必须等待，因此性能上有一定的损耗。
3. 饿汉式- 线程安全
线程不安全问题主要是由于 uniqueInstance 被实例化了多次，如果 uniqueInstance 采用直接实例化的话，就不会被实例化多次，也就不会产生线程不安全问题。但是直接实例化的方式也丢失了延迟实例化带来的节约资源的优势。
4. 双重校验锁-线程安全

uniqueInstance 只需要被实例化一次，之后就可以直接使用了。加锁操作只需要对实例化那部分的代码进行。也就是说，只有当 uniqueInstance 没有被实例化时，才需要进行加锁。

双重校验锁先判断 uniqueInstance 是否已经被实例化，如果没有被实例化，那么才对实例化语句进行加锁。
5. 静态内部类实现
当 Singleton 类加载时，静态内部类 SingletonHolder 没有被加载进内存。只有当调用 getUniqueInstance() 方法从而触发 SingletonHolder.INSTANCE 时 SingletonHolder 才会被加载，此时初始化 INSTANCE 实例。

这种方式不仅具有延迟初始化的好处，而且由虚拟机提供了对线程安全的支持。
```
public class Singleton {

    private Singleton() {
    }

    private static class SingletonHolder {
        private static final Singleton INSTANCE = new Singleton();
    }

    public static Singleton getUniqueInstance() {
        return SingletonHolder.INSTANCE;
    }
}
```
6. 枚举实现
这是单例模式的最佳实践，它实现简单，并且在面对复杂的序列化或者反射攻击的时候，能够防止实例化多次。
```java
public enum Singleton {
    uniqueInstance;
}
```
如果不使用枚举来实现单例模式，会出现反射攻击，因为通过 setAccessible() 方法可以将私有构造函数的访问级别设置为 public，然后调用构造函数从而实例化对象。如果要防止这种攻击，需要在构造函数中添加防止实例化第二个对象的代码。

从上面的讨论可以看出，解决序列化和反射攻击很麻烦，而枚举实现不会出现这两种问题，所以说枚举实现单例模式是最佳实践。
#### 使用场景
- Logger Classes
- Configuration Classes
- Accesing resources in shared mode
- Factories implemented as Singletons
### 2. 简单工厂(Simple Factory)
#### 意图  
在创建一个对象时不向客户暴漏内部细节，并提供一个创建对象的通用接口。
#### 类图
简单工厂不是设计模式，更像是一种编程习惯。它把实例化的操作单独放到一个类中，这个类就成为简单工厂类，让简单工厂类来决定应该用哪个具体子类来实例化。简单工厂不是设计模式，更像是一种编程习惯。它把实例化的操作单独放到一个类中，这个类就成为简单工厂类，让简单工厂类来决定应该用哪个具体子类来实例化。
### 3. 工厂方法(Factory Method)
#### 意图
定义了一个创建对象的接口，但由子类决定要实例化哪个类。工厂方法把实例化推迟到子类。
#### 类图
在简单工厂中，创建对象的是另一个类，而在工厂方法中，是由子类来创建对象。

### 抽象工厂（Abstract Factory)
#### 意图
提供一个接口，用于创建相关的对象家族。
#### 类图
抽象工厂模式创建的是对象家族，也就是很多对象而不是一个对象，并且这些对象是相关的，也就是说必须一起创建出来。而工厂方法模式只是用于创建一个对象，这和抽象工厂模式有很大不同。

抽象工厂模式用到了工厂方法模式来创建单一对象，AbstractFactory 中的 createProductA() 和 createProductB() 方法都是让子类来实现，这两个方法单独来看就是在创建一个对象，这符合工厂方法模式的定义。

至于创建对象的家族这一概念是在 Client 体现，Client 要通过 AbstractFactory 同时调用两个方法来创建出两个对象，在这里这两个对象就有很大的相关性，Client 需要同时创建出这两个对象。

从高层次来看，抽象工厂使用了组合，即 Cilent 组合了 AbstractFactory，而工厂方法模式使用了继承。
### 生成器（Builder)
#### 意图
封装一个对象的构造过程，并允许按步骤构造。
#### 类图
#### JDK
- java.long.StringBulider
- java.nio.ByteBuffer
- java.long.Appendable
- Apache Camel builders
### 原型模式（Prototype)
#### 意图
使用原型实例指定要创建对象的类型，通过复制这个原型来创建新对象。
#### JDK
- java.long.Object#clone()
## 行为型
### 1. 责任链（ Chain Of Responsibility)
#### 意图
使多个对象都有机会处理请求，从而
避免请求的发送者和接受者之间的耦合关系，将这些对象连成一条链，并沿着这条链发送该请求，直到有一个对象处理它为止。
#### JDK
- java.util.logging.Logger#log()
- Apache Commons Chain
- javax.servlet.Filter#doFilter()
### 命令（Command)
#### 意图
将命令封装成对象中，以便使用命令来参数化其它对象，或者将命令对象放入队列中进行排队，或者将命令对象的操作记录到日志中，以及支持可撤销的操作。
#### JDK
- java.long.Runnable
- Netflix Hystrix
## 结构型模式
共7种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。
### 6. 适配器模式（Adapter)
适配器模式将某个类的接口转换成客户端期望的另一个接口表示，目的是消除接口不匹配所造成的兼容性问题。
主要分为三类：类的适配器模式、对象的适配器模式、接口的适配器模式。
1. 类的适配器模式
核心思想是：有一个Source类，拥有一个方法，待适配，目标接口是Targetable,通过Adapter类，将Source的功能扩展到Targetable里。
2. 对象的适配器模式
只是将Adapter类做修改，这次不继承Source类，而是持有Source类的实例，以达到解决兼容性问题。
3. 接口的适配器模式。
在接口中定义了太多的方法，以至于有时实现类中并不是都需要。
所以，借助于一个抽象类实现该接口，然后我们写一个继承该类，重写我们需要的方法。
### 7. 装饰模式（Decorator)
装饰模式就是给一个对象增加一些新的功能，而且是动态的，
要求装饰对象和被装饰对象实现同一个接口，
装饰对象持有被装饰对象的实例
应用场景：
1. 需要扩展一个类的功能
2. 动态的为一个对象增加功能，而且还能动态撤销。（继承不能做到这一点，继承的功能是静态的，不能动态删除）
缺点：产生过多相似的对象，不易排错！
### 8. 代理模式（Proxy)
应用场景：
如果已有的方法在使用的时候需要对原有的方法进行改进，此时有两种办法：
1. 修改原有的方法来适应。这样违反了“对扩展开放，对修改关闭”的原则。
2. 就是采用一个代理类调用原有的方法，且对产生的结果进行控制。这种方法就是代理模式。
使用代理模式，可以将功能划分的更加清晰，有助于后期维护！
### 9. 外观模式（Facade)
外观模式是为了解决类与类之家的依赖关系的，
像spring一样，可以将类和类之间的关系配置到配置文件中，
而外观模式就是将他们的关系放在一个Facade类中，
降低了类类之间的耦合度，该模式中没有涉及到接口，
看下类图：（我们以一个计算机的启动过程为例）
### 10. 桥接模式（Bridge）
桥接模式就是把事物和其具体实现分开，使他们可以各自独立的变化。
桥接的用意是：将抽象化与实现化解偶，使得二者独立变化。
如：JDBC的DriverManager一样。
### 11. 组合模式（Composite)
组合模式有时又叫部分-整体模式。
例如表示树形结构
### 12. 享元模式（Flyweight)
享元模式的主要目的是实现对象的共享，即共享池。
当系统中对象多的时候可以减少内存的开销
通常与工厂模式一起使用。
FlyWeightFactory负责创建和管理享元单元，当一个客户端请求时，工厂需要检查当前对象池中是否有符合条件的对象，如果有，就返回已经存在的对象，如果没有，则创建一个新对象，FlyWeight是超类。一提到共享池，我们很容易联想到Java里面的JDBC连接池，想想每个连接的特点，我们不难总结出：适用于作共享的一些个对象，他们有一些共有的属性，就拿数据库连接池来说，url、driverClassName、username、password及dbname，这些属性对于每个连接来说都是一样的，所以就适合用享元模式来处理，建一个工厂类，将上述类似属性作为内部数据，其它的作为外部数据，在方法调用时，当做参数传进来，这样就节省了空间，减少了实例的数量。
## 关系模式（11种）
- 第一类：通过父类与子类的关系进行实现。
    1. 策略模式
    2. 模板方法模式
- 第二类：两个类之间
    3. 观察者模式
    4. 迭代器模式
    5. 责任链模式
    6. 命令模式
- 第三类： 类的状态
    7. 备忘录模式
    8. 状态模式
- 第四类： 通过中间类
    9. 访问者模式
    10. 中介者模式
    11. 解释器模式
### 父类与子类关系
### 13. 策略模式（strategy)
策略模式定义了一系列算法，并将每个算法封装起来，使他们可以相互替换，且算法的变化不会影响到使用算法的客户。
需要设计一个接口，为一系列实现类提供统一的方法，多个实现类实现该接口，设计一个抽象类（可有可无，属于辅助类），提供辅助函数，关系图如下：
策略模式的决定权在用户，系统本身提供不同算法的实现，新增或者删除算法，对各种算法做封装。因此，策略模式多用在算法决策系统中，外部用户只需要决定用哪个算法即可。
### 14. 模板方法模式（Templete Method)
解释一下模板方法模式，就是指：一个抽象类中，有一个主方法，再定义1...n个方法，可以是抽象的，也可以是实际的方法，定义一个类，继承该抽象类，重写抽象方法，通过调用抽象类，实现对子类的调用，先看个关系图：
### 类之间关系
### 15. 观察者模式（Observer）
包括这个模式在内的接下来的四个模式，都是类和类之间的关系，不涉及到继承，学的时候应该 记得归纳，记得本文最开始的那个图。观察者模式很好理解，类似于邮件订阅和RSS订阅，当我们浏览一些博客或wiki时，经常会看到RSS图标，就这的意思是，当你订阅了该文章，如果后续有更新，会及时通知你。其实，简单来讲就一句话：当一个对象变化时，其它依赖该对象的对象都会收到通知，并且随着变化！对象之间是一种一对多的关系。先来看看关系图：
### 16. 迭代器模式（Iterator)
迭代器模式就是顺序访问聚集中的对象，一般来说，集合中非常常见，如果对集合类比较熟悉的话，理解本模式会十分轻松。这句话包含两层意思：一是需要遍历的对象，即聚集对象，二是迭代器对象，用于对聚集对象进行遍历访问。我们看下关系图：
### 17. 责任链模式（Chain of Responsibility)
接下来我们将要谈谈责任链模式，有多个对象，每个对象持有对下一个对象的引用，这样就会形成一条链，请求在这条链上传递，直到某一对象决定处理该请求。但是发出者并不清楚到底最终那个对象会处理该请求，所以，责任链模式可以实现，在隐瞒客户端的情况下，对系统进行动态的调整。先看看关系图
### 18. 命令模式（Command)
命令模式很好理解，举个例子，司令员下令让士兵去干件事情，从整个事情的角度来考虑，司令员的作用是，发出口令，口令经过传递，传到了士兵耳朵里，士兵去执行。这个过程好在，三者相互解耦，任何一方都不用去依赖其他人，只需要做好自己的事儿就行，司令员要的是结果，不会去关注到底士兵是怎么实现的。我们看看关系图
### 19. 备忘录模式(Memento)
主要目的是保存一个对象的某个状态，以便在适当的时候恢复对象，个人觉得叫备份模式更形象些，通俗的讲下：假设有原始类A，A中有各种属性，A可以决定需要备份的属性，备忘录类B是用来存储A的一些内部状态，类C呢，就是一个用来存储备忘录的，且只能存储，不能修改等操作。做个图来分析一下：
### 20. 状态模式（state)
核心思想就是：当对象的状态改变时，同时改变其行为，
### 通过中间类
### 21. 访问者模式 Visitor
访问者模式把数据结构和作用于结构上的操作解耦合，使得操作集合可相对自由地演化。访问者模式适用于数据结构相对稳定算法又易变化的系统。因为访问者模式使得算法操作增加变得容易。若系统数据结构对象易于变化，经常有新的数据对象增加进来，则不适合使用访问者模式。访问者模式的优点是增加操作很容易，因为增加操作意味着增加新的访问者。访问者模式将有关行为集中到一个访问者对象中，其改变不影响系统数据结构。其缺点就是增加新的数据结构很困难。
### 22. 中介者模式 Mediator
中介者模式也是用来降低类类之间的耦合的，因为如果类类之间有依赖关系的话，不利于功能的拓展和维护，因为只要修改一个对象，其它关联的对象都得进行修改。如果使用中介者模式，只需关心和Mediator类的关系，具体类类之间的关系及调度交给Mediator就行，这有点像spring容器的作用。先看看图：
### 23. 解释器模式 Interpreter
解释器模式是我们暂时的最后一讲，一般主要应用在OOP开发中的编译器的开发中，所以适用面比较窄。 
